{"version":3,"file":"894.13a9d1e1.chunk.js","mappings":"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","sources":["webpack://@app/client/./src/components/example.tsx","webpack://@app/client/./src/lib/components/text.tsx","webpack://@app/client/./src/examples/typography.tsx","webpack://@app/client/./src/lib/components/surface.tsx","webpack://@app/client/./src/lib/context/surface-context.tsx","webpack://@app/client/./src/lib/hooks/use-render-key.tsx","webpack://@app/client/./src/lib/hooks/use-render-order.tsx","webpack://@app/client/./src/lib/state/surfaces.ts"],"sourcesContent":["import React from \"react\";\nimport { BoxLineGeometry } from \"three/examples/jsm/geometries/BoxLineGeometry\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { OrbitControls, PerspectiveCamera } from \"@react-three/drei\";\n\ntype Props = {\n  children?: React.ReactNode;\n};\n\nexport default function Example({ children }: Props) {\n  const room = React.useMemo(() => {\n    return new BoxLineGeometry(6, 6, 6, 10, 10, 10).translate(0, 3, 0);\n  }, []);\n\n  return (\n    <Canvas legacy flat linear gl={{ localClippingEnabled: true }}>\n      {/** Cameras, controls and lights */}\n      <PerspectiveCamera makeDefault position={[0, 1.6, 0]} />\n      <OrbitControls makeDefault target={[0, 1, -1.8]} />\n      <ambientLight />\n\n      <lineSegments geometry={room}>\n        <lineBasicMaterial color=\"#c0c0c0\" />\n      </lineSegments>\n\n      <group position={[0, 1, -1.88]}>{children}</group>\n    </Canvas>\n  );\n}\n","import * as React from \"react\";\nimport * as THREE from \"three\";\n// @ts-ignore\nimport { Text as TextMeshImpl, preloadFont } from \"troika-three-text\";\nimport { ReactThreeFiber, useThree } from \"@react-three/fiber\";\nimport { suspend } from \"suspend-react\";\nimport { mergeRefs } from \"react-merge-refs\";\nimport useRenderOrder from \"@/lib/hooks/use-render-order\";\nimport useRenderKey from \"@/lib/hooks/use-render-key\";\nimport Surface from \"@/lib/components/surface\";\nimport surfaces from \"@/lib/state/surfaces\";\nimport { SurfaceContext } from \"@/lib/context/surface-context\";\n\ntype Props = JSX.IntrinsicElements[\"mesh\"] & {\n  children: React.ReactNode;\n  characters?: string;\n  color?: ReactThreeFiber.Color;\n  fontSize?: number;\n  maxWidth?: number;\n  lineHeight?: number;\n  letterSpacing?: number;\n  textAlign?: \"left\" | \"right\" | \"center\" | \"justify\";\n  font?: string;\n  anchorX?: number | \"left\" | \"center\" | \"right\";\n  anchorY?:\n    | number\n    | \"top\"\n    | \"top-baseline\"\n    | \"middle\"\n    | \"bottom-baseline\"\n    | \"bottom\";\n  clipRect?: [number, number, number, number];\n  depthOffset?: number;\n  direction?: \"auto\" | \"ltr\" | \"rtl\";\n  overflowWrap?: \"normal\" | \"break-word\";\n  whiteSpace?: \"normal\" | \"overflowWrap\" | \"overflowWrap\";\n  outlineWidth?: number | string;\n  outlineOffsetX?: number | string;\n  outlineOffsetY?: number | string;\n  outlineBlur?: number | string;\n  outlineColor?: ReactThreeFiber.Color;\n  outlineOpacity?: number;\n  strokeWidth?: number | string;\n  strokeColor?: ReactThreeFiber.Color;\n  strokeOpacity?: number;\n  fillOpacity?: number;\n  debugSDF?: boolean;\n  onSync?: (troika: TextMeshImpl) => void;\n};\n\nfunction Text(\n  {\n    anchorX = \"center\",\n    anchorY = \"middle\",\n    font,\n    children,\n    characters,\n    onSync,\n    ...props\n  }: Props,\n  forwardedRef: React.ForwardedRef<THREE.Group>\n) {\n  const invalidate = useThree(({ invalidate }) => invalidate);\n  const [troikaMesh] = React.useState(() => new TextMeshImpl());\n\n  const [nodes, text] = React.useMemo(() => {\n    const n: React.ReactNode[] = [];\n    let t = \"\";\n    React.Children.forEach(children, (child) => {\n      if (typeof child === \"string\" || typeof child === \"number\") {\n        t += child;\n      } else {\n        n.push(child);\n      }\n    });\n    return [n, t];\n  }, [children]);\n\n  suspend(\n    () => new Promise((res) => preloadFont({ font, characters }, res)),\n    [\"troika-text\", font, characters]\n  );\n\n  const groupRef = React.useRef<THREE.Group>(null);\n\n  const renderOrder = useRenderOrder();\n  const key = useRenderKey([children]);\n\n  React.useMemo(() => {\n    troikaMesh.renderOrder = renderOrder + 2;\n    const material = troikaMesh.material as THREE.MeshBasicMaterial;\n    material.side = THREE.FrontSide;\n    material.depthWrite = false;\n    material.needsUpdate = true;\n  }, [troikaMesh, renderOrder]);\n\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n\n  React.useLayoutEffect(\n    () =>\n      void troikaMesh.sync(() => {\n        invalidate();\n        const width = troikaMesh.geometry.boundingBox.max.x * 2;\n        const height = troikaMesh.geometry.boundingBox.max.y * 2;\n        setSize({ width, height });\n        if (onSync) onSync(troikaMesh);\n      })\n  );\n\n  React.useEffect(() => {\n    return () => troikaMesh.dispose();\n  }, [troikaMesh]);\n\n  const id = React.useId();\n\n  const { parentId } = React.useContext(SurfaceContext);\n\n  React.useEffect(() => {\n    const group = groupRef.current;\n    if (group === null) return;\n    if (parentId === undefined) return;\n    if (!surfaces.hasOwnProperty(parentId)) {\n      surfaces[parentId] = [];\n    }\n    surfaces[parentId].push({ ...size, id });\n  }, [parentId, size, id]);\n\n  return (\n    <Surface\n      width={size.width}\n      height={size.height}\n      ref={groupRef}\n      key={key}\n      backgroundOpacity={0}\n    >\n      <primitive\n        object={troikaMesh}\n        ref={mergeRefs([groupRef, forwardedRef])}\n        font={font}\n        text={text}\n        anchorX={anchorX}\n        anchorY={anchorY}\n        {...props}\n      >\n        {nodes}\n      </primitive>\n    </Surface>\n  );\n}\n\nconst Component = React.forwardRef(Text);\n\nComponent.displayName = \"ui-text\";\n\nexport default Component;\n","import React from \"react\";\nimport Example from \"@/components/example\";\nimport Surface from \"@/lib/components/surface\";\nimport Text from \"@/lib/components/text\";\n\nexport default function Typography() {\n  return (\n    <Example>\n      <Surface\n        backgroundColor=\"#777777\"\n        width={1}\n        height={1}\n        justifyContent=\"center\"\n        flexDirection=\"column\"\n        alignItems=\"center\"\n        gap={0.05}\n      >\n        <Surface\n          width={0.5}\n          height={0.5}\n          backgroundColor=\"#555555\"\n          alignItems=\"start\"\n        >\n          <Text fontSize={0.1} color=\"white\" textAlign=\"center\">\n            {`Some Very Long\\nText`}\n          </Text>\n        </Surface>\n      </Surface>\n    </Example>\n  );\n}\n","import React from \"react\";\nimport { mergeRefs } from \"react-merge-refs\";\nimport * as THREE from \"three\";\nimport { useThree } from \"@react-three/fiber\";\nimport { ThreeEvent } from \"@react-three/fiber/dist/declarations/src/core/events\";\nimport useRenderOrder from \"@/lib/hooks/use-render-order\";\nimport useRenderKey from \"@/lib/hooks/use-render-key\";\nimport surfaces from \"@/lib/state/surfaces\";\nimport { SurfaceContext } from \"@/lib/context/surface-context\";\n\ntype Props = {\n  children?: React.ReactNode;\n  width?: number;\n  height?: number;\n  backgroundColor?: THREE.ColorRepresentation;\n  backgroundImage?: string;\n  backgroundSize?: \"cover\" | \"contain\";\n  backgroundOpacity?: number;\n  flexDirection?: \"row\" | \"column\" | \"row-reverse\" | \"column-reverse\";\n  alignItems?: \"start\" | \"center\" | \"end\";\n  justifyContent?:\n    | \"start\"\n    | \"center\"\n    | \"end\"\n    | \"space-between\"\n    | \"space-around\";\n  gap?: number;\n  zIndex?: number;\n  position?: [x: number, y: number, z: number];\n  rotation?: [x: number, y: number, z: number];\n  onClick?: (event: ThreeEvent<MouseEvent>) => void;\n  onContextMenu?: (event: ThreeEvent<MouseEvent>) => void;\n  onDoubleClick?: (event: ThreeEvent<MouseEvent>) => void;\n  onPointerUp?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerDown?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerOver?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerOut?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerEnter?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerLeave?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerMove?: (event: ThreeEvent<PointerEvent>) => void;\n  onPointerMissed?: (event: MouseEvent) => void;\n  onPointerCancel?: (event: ThreeEvent<PointerEvent>) => void;\n  onWheel?: (event: ThreeEvent<WheelEvent>) => void;\n};\n\nfunction Surface(\n  {\n    children,\n    width = 1,\n    height = 1,\n    backgroundColor = \"black\",\n    backgroundImage,\n    backgroundSize,\n    backgroundOpacity = 1,\n    zIndex = 0,\n    position,\n    rotation,\n    flexDirection = \"row\",\n    alignItems = \"start\",\n    justifyContent = \"start\",\n    gap = 0,\n    onClick,\n    onContextMenu,\n    onDoubleClick,\n    onPointerUp,\n    onPointerDown,\n    onPointerOver,\n    onPointerOut,\n    onPointerEnter,\n    onPointerLeave,\n    onPointerMove,\n    onPointerMissed,\n    onPointerCancel,\n    onWheel,\n  }: Props,\n  forwardedRef: React.ForwardedRef<THREE.Group>\n) {\n  const gl = useThree((state) => state.gl);\n\n  // Set geometry size from `width` and `height` props\n  const size = React.useMemo(() => {\n    return { width, height };\n  }, [width, height]);\n\n  // Set material texture from `backgroundImage` prop\n  const [texture, setTexture] = React.useState<THREE.Texture>(undefined);\n  React.useMemo(() => {\n    if (backgroundImage === undefined) return;\n    new THREE.TextureLoader().loadAsync(backgroundImage).then(setTexture);\n  }, [backgroundImage]);\n\n  // Set texture `anisotropy` to max available (prevents blurriness)\n  // when viewing at an angle\n  React.useMemo(() => {\n    if (texture === undefined) return;\n    texture.anisotropy = gl.capabilities.getMaxAnisotropy();\n  }, [texture, gl]);\n\n  const [surfaceRatio, imageRatioX, imageRatioY] = React.useMemo(() => {\n    const surfaceRatio = size.width / size.height;\n    if (texture === undefined) {\n      return [surfaceRatio, surfaceRatio, surfaceRatio];\n    }\n    const imageRatioX = texture.image.width / texture.image.height;\n    const imageRatioY = texture.image.height / texture.image.width;\n    return [surfaceRatio, imageRatioX, imageRatioY];\n  }, [texture, size]);\n\n  const [clippingPlanes, setClippingPlanes] = React.useState<THREE.Plane[]>(\n    () => {\n      const plane = new THREE.Plane(new THREE.Vector3(), 1);\n      return [plane.clone(), plane.clone(), plane.clone(), plane.clone()];\n    }\n  );\n\n  const [textureSize, setTextureSize] = React.useState(() => {\n    return { ...size };\n  });\n\n  const nodes = React.useMemo(() => {\n    if (children === undefined) return [];\n    if (!Array.isArray(children)) return [children];\n    return children;\n  }, [children]);\n\n  const vec = React.useMemo(() => {\n    return new THREE.Vector2(0, 0);\n  }, []);\n\n  const { parentId } = React.useContext(SurfaceContext);\n\n  const getChildPosition = React.useCallback(\n    // @todo fix types\n    (index: number): Props[\"position\"] => {\n      const displayName = nodes[index].type.displayName ?? \"\";\n      if (![\"ui-surface\"].includes(displayName)) return [0, 0, 0];\n      // @todo simplify this\n      const width = nodes.reduce((width, node) => width + node.props.width, 0);\n      const height = nodes.reduce(\n        (height, node) => height + node.props.height,\n        0\n      );\n\n      vec.set(0, 0);\n\n      let contentSize = width;\n\n      type Axis = \"width\" | \"height\";\n\n      let axis: Axis = \"width\";\n      let axisInverted: Axis = \"height\";\n      if (flexDirection === \"column\") {\n        axis = \"height\";\n        axisInverted = \"width\";\n        contentSize = height;\n      }\n\n      if (\n        nodes.length > 0 &&\n        ![\"space-between\", \"space-around\"].includes(justifyContent)\n      ) {\n        contentSize += gap * (nodes.length - 1);\n      }\n\n      /**\n       * justifyContent\n       */\n      if (justifyContent === \"start\") {\n        vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - size[axis];\n        for (let i = 1; i <= index; i++) {\n          vec.x +=\n            nodes[i - 1].props[axis] * 0.5 + nodes[i].props[axis] * 0.5 + gap;\n        }\n      }\n      if (justifyContent === \"center\") {\n        vec.x = nodes[0].props[axis] * 0.5 - contentSize * 0.5;\n        for (let i = 1; i <= index; i++) {\n          vec.x +=\n            nodes[i - 1].props[axis] * 0.5 + nodes[i].props[axis] * 0.5 + gap;\n        }\n      }\n      if (justifyContent === \"end\") {\n        vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - contentSize;\n        for (let i = 1; i <= index; i++) {\n          vec.x +=\n            nodes[i - 1].props[axis] * 0.5 + nodes[i].props[axis] * 0.5 + gap;\n        }\n      }\n      if (justifyContent === \"space-between\") {\n        if (contentSize >= size[axis]) {\n          vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - size[axis];\n          for (let i = 1; i <= index; i++) {\n            vec.x +=\n              nodes[i - 1].props[axis] * 0.5 + nodes[i].props[axis] * 0.5;\n          }\n        } else {\n          let spacing = Math.max(0, size[axis] - contentSize);\n          if (nodes.length === 0) {\n            spacing = 0;\n          } else if (spacing > 0) {\n            spacing /= nodes.length - 1;\n          }\n          vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - size[axis];\n          for (let i = 1; i <= index; i++) {\n            vec.x +=\n              nodes[i - 1].props[axis] * 0.5 +\n              nodes[i].props[axis] * 0.5 +\n              spacing;\n          }\n        }\n      }\n      if (justifyContent === \"space-around\") {\n        if (contentSize >= size[axis]) {\n          vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - size[axis];\n          for (let i = 1; i <= index; i++) {\n            vec.x +=\n              nodes[i - 1].props[axis] * 0.5 + nodes[i].props[axis] * 0.5;\n          }\n        } else {\n          let spacing = Math.max(0, size[axis] - contentSize);\n          if (nodes.length === 0) {\n            spacing = 0;\n          } else if (spacing > 0) {\n            spacing /= nodes.length + 1;\n          }\n          vec.x = size[axis] * 0.5 + nodes[0].props[axis] * 0.5 - size[axis];\n          vec.x += spacing;\n          for (let i = 1; i <= index; i++) {\n            vec.x +=\n              nodes[i - 1].props[axis] * 0.5 +\n              nodes[i].props[axis] * 0.5 +\n              spacing;\n          }\n        }\n      }\n\n      /**\n       * alignItems\n       */\n      if (alignItems === \"start\") {\n        if (flexDirection === \"row\") {\n          vec.y =\n            size[axisInverted] * 0.5 - nodes[index].props[axisInverted] * 0.5;\n        }\n        if (flexDirection === \"column\") {\n          vec.y =\n            size[axisInverted] * -0.5 + nodes[index].props[axisInverted] * 0.5;\n        }\n      }\n      if (alignItems === \"center\") {\n        // No calculation needed\n      }\n      if (alignItems === \"end\") {\n        if (flexDirection === \"row\") {\n          vec.y =\n            size[axisInverted] * -0.5 + nodes[index].props[axisInverted] * 0.5;\n        }\n        if (flexDirection === \"column\") {\n          vec.y =\n            size[axisInverted] * 0.5 - nodes[index].props[axisInverted] * 0.5;\n        }\n      }\n\n      if (flexDirection === \"column\") {\n        return [vec.y, vec.x, 0];\n      }\n\n      return [vec.x, vec.y, 0];\n    },\n    [nodes, size, flexDirection, alignItems, justifyContent, gap, vec, parentId]\n  );\n\n  const [childPositions, setChildPositions] = React.useState<\n    Props[\"position\"][]\n  >(() => {\n    return nodes.map((node, index) => getChildPosition(index));\n  });\n\n  React.useEffect(() => {\n    setChildPositions(nodes.map((node, index) => getChildPosition(index)));\n  }, [nodes, getChildPosition]);\n\n  React.useEffect(() => {\n    if (texture === undefined) return;\n\n    const newSize = { ...size };\n\n    if (backgroundSize === \"contain\") {\n      if (imageRatioX >= surfaceRatio) {\n        newSize.width = size.width;\n        newSize.height = newSize.width * imageRatioY;\n      } else {\n        newSize.height = size.height;\n        newSize.width = newSize.height * imageRatioX;\n      }\n    }\n\n    if (backgroundSize === \"cover\") {\n      if (imageRatioX >= surfaceRatio) {\n        newSize.height = size.height;\n        newSize.width = newSize.height * imageRatioX;\n      } else {\n        newSize.width = size.width;\n        newSize.height = newSize.width * imageRatioY;\n      }\n    }\n\n    setTextureSize(newSize);\n    setClippingPlanes((planes) => {\n      planes[0].set(new THREE.Vector3(0, -1, 0), size.height * 0.5);\n      planes[1].set(new THREE.Vector3(1, 0, 0), size.width * 0.5);\n      planes[2].set(new THREE.Vector3(0, 1, 0), size.height * 0.5);\n      planes[3].set(new THREE.Vector3(-1, 0, 0), size.width * 0.5);\n      return [...planes];\n    });\n  }, [\n    rotation,\n    position,\n    childPositions,\n    texture,\n    size,\n    backgroundSize,\n    imageRatioX,\n    imageRatioY,\n    surfaceRatio,\n  ]);\n\n  const groupRef = React.useRef<THREE.Group>(null);\n\n  React.useEffect(() => {\n    const group = groupRef.current;\n    if (group === null) return;\n    group.updateMatrixWorld(true);\n    clippingPlanes.forEach((plane) => {\n      plane.applyMatrix4(group.matrixWorld);\n    });\n  }, [rotation, position, childPositions, clippingPlanes]);\n\n  const renderOrder = useRenderOrder();\n  const key = useRenderKey([\n    childPositions,\n    texture,\n    rotation,\n    position,\n    children,\n    textureSize,\n    clippingPlanes,\n  ]);\n\n  const id = React.useId();\n\n  React.useEffect(() => {\n    const group = groupRef.current;\n    if (group === null) return;\n    if (parentId === undefined) return;\n    if (!surfaces.hasOwnProperty(parentId)) {\n      surfaces[parentId] = [];\n    }\n    surfaces[parentId].push({ ...size, id });\n  }, [size, parentId, id]);\n\n  return (\n    <group\n      ref={mergeRefs([groupRef, forwardedRef])}\n      key={key}\n      rotation={rotation}\n      position={position}\n      onClick={onClick}\n      onContextMenu={onContextMenu}\n      onDoubleClick={onDoubleClick}\n      onPointerUp={onPointerUp}\n      onPointerDown={onPointerDown}\n      onPointerOver={onPointerOver}\n      onPointerOut={onPointerOut}\n      onPointerEnter={onPointerEnter}\n      onPointerLeave={onPointerLeave}\n      onPointerMove={onPointerMove}\n      onPointerMissed={onPointerMissed}\n      onPointerCancel={onPointerCancel}\n      onWheel={onWheel}\n    >\n      <mesh renderOrder={renderOrder + zIndex}>\n        <planeBufferGeometry args={[size.width, size.height]} />\n        <meshBasicMaterial\n          color={backgroundColor}\n          opacity={backgroundOpacity}\n          transparent={true}\n          depthWrite={false}\n        />\n      </mesh>\n      <mesh renderOrder={renderOrder + zIndex} visible={texture !== undefined}>\n        <planeBufferGeometry args={[textureSize.width, textureSize.height]} />\n        <meshBasicMaterial\n          map={texture}\n          opacity={backgroundOpacity}\n          transparent={true}\n          depthWrite={false}\n          clippingPlanes={clippingPlanes}\n        />\n      </mesh>\n      <SurfaceContext.Provider value={{ parentId: id }}>\n        {React.Children.map(children, (child: any, index) => {\n          return (\n            <group key={index} position={childPositions[index]}>\n              {child}\n            </group>\n          );\n        })}\n      </SurfaceContext.Provider>\n    </group>\n  );\n}\n\nconst Component = React.forwardRef(Surface);\n\nComponent.displayName = \"ui-surface\";\n\nexport default Component;\n","import React from \"react\";\n\nexport const SurfaceContext = React.createContext<any>({});\n","import React from \"react\";\n\nexport default function useRenderKey(deps: React.DependencyList | undefined) {\n  const lastKey = React.useRef(0);\n\n  return React.useMemo(() => {\n    let key = ++lastKey.current;\n    if (key > 1000) {\n      key = 0;\n      lastKey.current = key;\n    }\n    return key;\n  }, deps);\n}\n","import React from \"react\";\n\nlet lastRenderOrder = -1;\n\nexport default function useRenderOrder() {\n  return React.useMemo(() => {\n    return ++lastRenderOrder;\n  }, []);\n}\n","type Surface = {\n  id: string;\n  width: number;\n  height: number;\n};\n\nconst surfaces: { [parentId: string]: Surface[] } = {};\n\nexport default surfaces;\n"],"names":["Example","children","room","React","BoxLineGeometry","translate","legacy","flat","linear","gl","localClippingEnabled","makeDefault","position","target","geometry","color","Text","forwardedRef","anchorX","anchorY","font","characters","onSync","props","invalidate","useThree","troikaMesh","TextMeshImpl","nodes","text","n","t","child","push","suspend","Promise","res","preloadFont","groupRef","renderOrder","useRenderOrder","key","useRenderKey","material","side","THREE","depthWrite","needsUpdate","size","setSize","width","height","sync","boundingBox","max","x","y","dispose","id","parentId","SurfaceContext","current","undefined","surfaces","ref","backgroundOpacity","object","mergeRefs","Component","displayName","Typography","backgroundColor","justifyContent","flexDirection","alignItems","gap","fontSize","textAlign","Surface","backgroundImage","backgroundSize","zIndex","rotation","onClick","onContextMenu","onDoubleClick","onPointerUp","onPointerDown","onPointerOver","onPointerOut","onPointerEnter","onPointerLeave","onPointerMove","onPointerMissed","onPointerCancel","onWheel","state","texture","setTexture","loadAsync","then","anisotropy","capabilities","getMaxAnisotropy","surfaceRatio","imageRatioX","imageRatioY","image","clippingPlanes","setClippingPlanes","plane","clone","textureSize","setTextureSize","Array","isArray","vec","getChildPosition","index","type","includes","reduce","node","set","contentSize","axis","axisInverted","length","i","spacing","Math","childPositions","setChildPositions","map","newSize","planes","group","updateMatrixWorld","forEach","applyMatrix4","matrixWorld","args","opacity","transparent","visible","value","deps","lastKey","lastRenderOrder"],"sourceRoot":""}